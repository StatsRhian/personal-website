{
  "hash": "b465799ae751cb1a04d5bc4ac3fcd4bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Map and Nest\"\ndescription: \"I want to share a framework that I like using occasionally for data analysis.\"\ndate: \"2024-08-08\"\ncategories: [purrr, R, tutorial]\nimage: \"purrr.png\"\nimg-alt: \"Hex sticker for the purrr package. A line drawing of a cat curled up.\"\n---\n\n\n\nI want to share a framework that I like using occasionally for data analysis. It's the map-and-nest and it's helped me countless times when I'm working with related datasets. By combining [{purrr}](https://purrr.tidyverse.org/) mapping with [{tidyr}](https://tidyr.tidyverse.org/) nesting, I can keep my analysis steps linked, allowing me to easily track from a summary or plot, back to the original data.\n\nThe main funtions we'll need are \n\n- `tidyr::nest()`\n- `dplyr::mutate()`\n- `purrr::map()`\n- `purrr::walk()`\n\n## Example on NHS workforce statistics \n\nThe [NHS workforce statistics](https://digital.nhs.uk/data-and-information/publications/statistical/nhs-workforce-statistics) are official statistics published monthly for England.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstaff_group <- readRDS(file = \"workforce_staff_group.rds\")\n```\n:::\n\n\n\nI want to perform an analysis for each of the 42 integrated care systems (ICS). The {tidyr} `nest()` function creates a list-column, where each cell contains a mini dataframe for each grouping.\n\nLet's group by ICS, and call the nested data column `raw_data`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by_ics <- staff_group |>\n    tidyr::nest(raw_data = -ics_name)\n```\n:::\n\n\n\nThe new column is a list-column, with each cell containing an entire tibble of data relating to that individual ICS.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' echo: false\nhead(group_by_ics)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 2\n  ics_name             raw_data         \n  <chr>                <list>           \n1 South East London    <tibble [8 Ã— 6]> \n2 North East London    <tibble [7 Ã— 6]> \n3 North Central London <tibble [12 Ã— 6]>\n4 North West London    <tibble [10 Ã— 6]>\n5 South West London    <tibble [8 Ã— 6]> \n6 Devon                <tibble [7 Ã— 6]> \n```\n\n\n:::\n:::\n\n\n\nWe can grab these mini datasets in the usual way and explore them interactively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by_ics$raw_data[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 Ã— 6\n  organisation_name           total hchs_doctors nurses_health_visitors midwives\n  <chr>                       <dbl>        <dbl>                  <dbl>    <dbl>\n1 Total                       58394         7108                  14939      926\n2 Guy's and St Thomas' NHS Fâ€¦ 21361         3003                   6196      281\n3 King's College Hospital NHâ€¦ 13158         2443                   4202      375\n4 Lewisham and Greenwich NHSâ€¦  6617          979                   2103      271\n5 London Ambulance Service Nâ€¦  7050            4                     44        0\n6 NHS South East London ICB     617            9                     43        0\n7 Oxleas NHS Foundation Trust  4094          200                   1196        0\n8 South London and Maudsley â€¦  5496          471                   1155        0\n# â„¹ 1 more variable: ambulance_staff <dbl>\n```\n\n\n:::\n:::\n\n\n\nNext, let's apply some simple processing, say converting absolute numbers into percentages, to each of the ICSs in turn.\n\n We use `mutate()` to create a new list-column `staff_percent` and `map()` to apply the processing function to each cell in turn. ^[In this example, we actually didn't need to nest first. We could have performed the `mutate()` step on the full dataset.]\n\n<details>\n<summary>See function definition for `convert_percent()`</summary> \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Convert percent\n#' @param raw_staff Tibble containing organisation_name, total and a number of staff categories\n#' @return Tibble like raw_staff but with staff categories represented as percentages rather than absolute numbers\nconvert_percent <- function(staff){\n    staff |>\n    dplyr::mutate(dplyr::across(.cols = -c(organisation_name, total),\n                  .fns =  \\(x)x/total)) |>\n    dplyr::rename(\"Doctors\" = \"hchs_doctors\",\n                  \"Nurses\" = \"nurses_health_visitors\",\n                  \"Ambulance staff\" = \"ambulance_staff\",\n                  \"Midwives\" = \"midwives\")\n}\n```\n:::\n\n\n</details>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprocessed_staff <-\ngroup_by_ics |>\n    dplyr::mutate(\n        staff_percent = purrr::map(raw_data, convert_percent)\n    )\n```\n:::\n\n\n\nWhere I think this map-and-nest process really comes into its own is creating plots. Often, I find myself wanting to create a couple of different plots for each grouping, and then optionally save the plots with sensible names. Particularly in the analysis stage, I like having these plots in the same row as the raw data, so I can quickly compare and validate.\n\nI've created two functions, `plot_barchart()` and `plot_waffle()` which take the data and create charts.\n\n<details>\n<summary>See definition for `plot_barchart()` & `plot_waffle()`</summary> \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Plot barchart\n#' Makes a bar chart of staff perentages by organisation\n#' @param df tibble of staff data in percent format\nplot_barchart <- function(df) {\n  df |>\n    dplyr::filter(organisation_name != \"Total\") |>\n    dplyr::select(-total) |>\n    tidyr::pivot_longer(cols = -c(organisation_name), names_to = \"job\", values_to = \"percent\") |>\n    ggplot2::ggplot(ggplot2::aes(x = percent, y = organisation_name, fill = job)) +\n    ggplot2::geom_col(position = \"dodge\") + \n    ggplot2::scale_x_continuous(labels = scales::percent_format(scale = 100)) +\n    ggplot2::labs(x = \"\", y = \"\") +\n    StrategyUnitTheme::scale_fill_su() + \n    ggplot2::theme_minimal() + \n    ggplot2::theme(legend.title = ggplot2::element_blank())\n}\n\n#' Plot waffle\n#' Makes a waffle chart to visualise staff breakdown at an ICS level\n#' @param raw_staff count data of staff\n#' @param title Title for the graphic\nplot_waffle <- function(raw_staff, title) {\nwaffle_data <-\nraw_staff |>\n    dplyr::filter(organisation_name == \"Total\") |>\n    dplyr::select(-total, -organisation_name) |>\n    tidyr::pivot_longer(cols = dplyr::everything(), names_to = \"names\", values_to = \"vals\") |>\n    dplyr::mutate(vals = round(vals / 100))\n\nggplot2::ggplot(waffle_data, ggplot2::aes(fill = names, values = vals)) +\n  waffle::geom_waffle(n_rows = 8, size = 0.33, colour = \"white\") +\n  ggplot2::coord_equal() +\n  ggplot2::theme_void() + \n  ggplot2::theme(legend.title = ggplot2::element_blank()) +\n  ggplot2::ggtitle(title)\n}\n```\n:::\n\n\n\n\n</details>\n\n Again, using `mutate()` I can create a new column called `barchart` and I can `map()` the function `plot_barchart()`, applying it to each row at a time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraphs <-\nprocessed_staff |>\n    dplyr::mutate(\n        barchart =  purrr::map(staff_percent, plot_barchart)\n    ) \n```\n:::\n\n\n\nThe resulting column `barchart` is again a list-column, but this time instead of containing a tibble, it holds a ggplot object. A whole ggplot in a single cell. ^[This totally blew my mind the first time I saw it ðŸ¤¯.]\n\nIf we want to pass two arguments to our function, we can replace `map()` with `map2()`. Here we're using `map2()` to pass the `ics_name` column to use as a title in our waffle plot. ^[We're mapping the relationship between the two inputs and the `plot_waffle()` with an anonymous function. This shorthand syntax for anonymous functions came in R v 4.1.0. For compatibility with older versions of R, you'll need the `~` operator. For the different ways you can specify functions in {purrr} see the [help file](https://purrr.tidyverse.org/reference/map.html).]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraphs <-\nprocessed_staff |>\n    dplyr::mutate(\n        waffle =  purrr::map2(raw_data, ics_name, \n            \\(data, title) plot_waffle(data, title)\n        )\n    ) \n```\n:::\n\n\n\n![An example bar chart plot](example_bar_chart.png)\n\n## Putting it all together\n\nAll of these `mutate()` steps can actually be called in one step. Here's the full workflow again in full after a little refactor.\nI've also used `pivot_longer()` to move the two plotting columns into a single plot column. This will make it easier for me to generate nice filenames, and save the plots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <-\nstaff_group |>\n    tidyr::nest(raw_data = -ics_name) |>\n    dplyr::mutate(\n        staff_percent = purrr::map(raw_data, convert_percent),\n        barchart =  purrr::map(staff_percent, plot_barchart),\n        waffle =  purrr::map2(raw_data, ics_name, \\(data, title) plot_waffle(data, title)) \n    )     |>\n    tidyr::pivot_longer(cols = c(barchart, waffle), names_to = \"plot_type\", values_to = \"plot\") |>\n    dplyr::mutate(filename = glue::glue(\"{snakecase::to_snake_case(ics_name)}_{plot_type}.png\"))\n```\n:::\n\n\n\nThe `walk()` family of functions in {purrr} are used when the function you're applying does not return an object, but is being used for it's side-effect, for example reading or writing files.\n\nHere we call `walk2()`, passing in both the filename column and the plots column are arguments to save all the plots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::walk2(\n  results$filename,\n  results$plot,\n  \\(filename, plot) ggplot2::ggsave(file.path(\"plots\", filename), plot, width = 10, height = 6)\n)\n```\n:::\n\n\n\nBy keeping everything together in one nested structure, I personally find it much easier to keep track of my analyses.\nIf you're doing a more complex or permenant analysis, you might want to consider setting up a more formal data processing pipeline, and following RAP principals. \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}